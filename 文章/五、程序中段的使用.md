五、程序中段的使用
C语言中的全局区（静态区），实际上对应着下述几个段：
只读数据段:RO Data
读写数据段：RW Data
未初始化数据段：BSS Data
一般来说，直接定义的全局变量在未初始化数据区，如果该变量有初始化则是在已初始化数据区（RW Data）,加上const修饰符将放置在只读区域(RO Data).
例如:
const char ro[ ]=”this is a readonlydata”; //只读数据段，不能改变ro数组中的内容，ro存放在只读数据段。
char rw1[ ]=”this is global readwrite data”; //已初始化读写数据段，可以改变数组rw1中的内容。应为数值/是赋值不是把”this is global readwrite data” 地址给了rw1，不能改变char rw1[ ]=”this is global readwrite data”; //已初始化读写数据段，可以改变数组rw1中的内容。应为数值/是赋值不是把”this is global readwrite data” 地址给了rw1，不能改变”this is global readwrite data”的数值。因为起是文字常量放在只读数据段中

char bss_1[100];//未初始化数据段

const char *ptrconst = “constant data”; //”constant data”放在只读数据段，不能改变ptrconst中的值，因为其是地址赋值。ptrconst指向存放“constant data”的地址，其为只读数据段。但可以改变ptrconst地址的数值，因其存放在读写数据段中。

实例讲解：
int main() 
{
    short b;//b放置在栈上，占用2个字节
    char a[100];//需要在栈上开辟100个字节，a的值是其首地址
    char s[]=”abcde”;
    //s在栈上，占用4个字节，“abcde”本身放置在只读数据存储区，占6字节。s是一个地址
    //常量，不能改变其地址数值，即s++是错误的。
    char *p1;//p1在栈上，占用4个字节
    char *p2 ="123456";//"123456"放置在只读数据存储区，占7个字节。p2在栈上，p2指向的内容不能更
    //改，但是p2的地址值可以改变，即p2++是对的。
    static char bss_2[100]; //局部未初始化数据段
    static int c=0 ; //局部（静态）初始化区
    p1 = (char *)malloc(10*sizeof(char)); //分配的内存区域在堆区
    strcpy(p1,”xxx”); //”xxx”放置在只读数据存储区，占5个字节
    free(p1); //使用free释放p1所指向的内存
    return 0;
}

说明：
1、只读数据段需要包括程序中定义的const型的数据（如：const char ro[]）,还包括程序中需要使用的数据如“123456”。对于const char ro[]和const char * ptrconst的定义，它们指向的内存都位于只读数据据区，其指向的内容都不允许修改。区别在于前者不允许在程序中修改ro的值，后者允许在程序中修改ptrconst本身的值。对于后者，改写成以下的形式，将不允许在程序中修改ptrconst本身的值：
const char * const ptrconst = “const data”;

2、读写数据段包含了已经初始化的全局变量static char rw1[]以及局部静态变量static char rw2[]。rw1和rw2的差别在于编译时，是在函数内部使用的还是可以在整个文件中使用。对于前者，static修饰在于控制程序的其他文件时候可以访问rw1变量，如果有static修饰，将不能在其他的C语言源文件中使用rw1，这种影响针对编译-连接的特性，但无论有static，变量rw1都将被放置在读写数据段。对于后者rw2,它是局部的静态变量，放置在读写数据区；如果不使用static修饰，其意义将完全改变，它将会是开辟在栈空间局部变量，而不是静态变量。

3、未初始化数据段，事例1中的bss_1[100]和 bss_2[200]在程序中代表未初始化的数据段。其区别在于前者是全局的变量，在所有文件中都可以使用；后者是局部的变量，只在函数内部使用。未初始化数据段不设置后面的初始化数值，因此必须使用数值指定区域的大小，编译器将根据大小设置BBS中需要增加的长度。

4、栈空间包括函数中内部使用的变量如short b和char a[100]，以及char *p1中p1这个变量的值。
    1）变量p1指向的内存建立在堆空间上，堆空间只能在程序内部使用，但是堆空间(例如p1指向的内存)可以作为返回值传递给其他函数处理。
    2）栈空间主要用于以下3类数据的存储：
        a、函数内部的动态变量
        b、函数的参数
        c、函数的返回值
    3）栈空间主要的用处是供函数内部的动态变量使用，变量的空间在函数开始之前开辟，在函数退出后由编译器自动回收。看一个例：
        int main( )
        {
            char *p = "tiger";
            p[1] = 'I';
            p++;
            printf("%sn",p);
        }
编译后提示：段错误

分析：
char *p = "tiger";系统在栈上开辟了4个字节存储p的数值。"tiger"在只读存储区中存储，因此"tiger"的内容不能改变，*p="tiger"，表示地址赋值，因此，p指向了只读存储区，因此改变p指向的内容会引起段错误。但是因为p是存放在栈上，因此p的数值是可以改变的，因此p++是正确的。













