// Top-level build file where you can add configuration options common to all sub-projects/modules.
buildscript {
    ext.kotlin_version = "1.4.31"
    repositories {
        google()
        mavenCentral()
        maven { url "https://plugins.gradle.org/m2/" }
        maven { url 'http://repo.duowan.com:8181/nexus/content/groups/public' }
    }
    dependencies {
        classpath "com.android.tools.build:gradle:4.2.0"
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
        classpath "de.undercouch:gradle-download-task:4.1.2"

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

String TAG = "root - [build.gradle]"

allprojects {
    repositories {
        google()
        mavenCentral()
        maven { url 'http://repo.duowan.com:8181/nexus/content/groups/public' }
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}

ext {
    versionCode_ = 4
    versionName_ = "1.0.7"
    versionInfo_ = "App 第四个版本，对一直功能进行优化"
    println "---------------${rootProject.getProjectDir().path}"
    logFile = new File("${rootProject.getProjectDir()}\\output\\releasesMsg.xml")
    if (!logFile.getParentFile().exists()) {
        logFile.getParentFile().mkdirs()
    }
}


//task writeBuildLogTask(group: "releaseApp", description: "将版本信息记录到指定的历史版本日志中") {
//
//
//    inputs.properties([versionCode: versionCode_,
//                       versionName: versionName_,
//                       versionInfo: versionInfo_])
//    outputs.file logFile
//
//    doFirst {
//
//        def properties = inputs.getProperties()
//        File log = outputs.getFiles().getSingleFile()
//        //将版本信息转换成实体类
//        def versionMsgBean = new versionMsg(properties)
//        def sw = new StringWriter()
//        def builder = new MarkupBuilder(sw)
//
//
//
//        if (!log.exists()) {
//            log.createNewFile()
//        }
//        println "+++++++++++++++++"
//        if (log.text != null) {
//            //文件中没有数据
//            if (log.text.length() <= 0) {
//                println "----------"
//                builder.releases {
//                    relase {
//                        versionCode(properties.versionCode)
//                        versionName(properties.versionName)
//                        versionInfo(properties.versionInfo)
//                    }
//                }
//                log.withWriter("utf-8") { writer ->
//                    writer.write(sw.toString())
//                }
//            } else {
//                builder.release {
//                    versionCode(properties.versionCode)
//                    versionName(properties.versionName)
//                    versionInfo(properties.versionInfo)
//                }
//
//                def lines = log.readLines()
//                def length = lines.size() - 1
//                def sBuffer = new StringBuffer()
//                lines.eachWithIndex { line, index ->
//                    if (index < length) {
//                        sBuffer.append(line).append("\r\n")
//                    } else {
//                        sBuffer.append(sw.toString()).append("\r\n").append(line)
//                    }
//                    println line
//                }
//                log.withWriter("utf-8") { writer ->
//                    writer.write(sBuffer.toString())
//                }
//            }
//        } else {
//            println "log's text is null"
//        }
//    }
//}


/**
 * 生成对应版本的版本信息文件
 */
task handleReleaseTask(group: "releaseApp", description: "生成版本历史记录信息文件，方便查看每个版本的变更记录") {
    File logFile = new File("")
    File versionFile = new File("")
    inputs.file logFile
    outputs.file versionFile

    doLast {
        def srcFile = inputs.files.singleFile
        def desFile = outputs.files.singleFile

        if (!desFile.exists()) {
            desFile.mkdirs()
        }
        def releases = new XmlParser().parse(srcFile)

        releases.each { release ->
            def versionCode = release.versionCode.text()
            def versionName = release.versionName.text()
            def versionInfo = release.versionInfo.text()
            println "versionCode: ${versionCode}   versionName: ${versionName} versionInfo: ${versionInfo}"

            def outFile = new File("${desFile.path}\\release-${versionName}.properties")
            outFile.withWriter { writer ->
                writer.write("versionCode: ${versionCode}   versionName: ${versionName} versionInfo: ${versionInfo}")
            }

        }
    }
}

task taskZ {

    println("$TAG taskZ")
    doLast {
        println("$TAG taskZ doLast")
    }
}

task taskX(group: "study") {
    doLast {
        println("$TAG taskX")
    }
}

rootProject.afterEvaluate { project ->
    println "$TAG ------------${project.name}"
    def taskClean = project.tasks.findByPath("clean")
    println "${taskClean.name}"
    if (taskClean == null) {
        throw new GradleException("$TAG the task clean is not found.")
    }
    //将testTask追加在clean的后面
    taskClean.doLast {
//        project.tasks.getByName("taskX").execute()
//        taskZ.execute()
        println "$TAG ---------taskClean.doLast --------------------"
    }
}

//project.gradle.addListener(
//        new DependencyCheckListener() {
//            def allTasks
//
//            @Override
//            void graphPopulated(TaskExecutionGraph graph) {
//                allTasks = graph.allTasks
//            }
//
//            @Override
//            void buildFinished(BuildResult result) {
//                println("trying to fire the dependency check")
//                dependencyCheck.dependencyUpdate() //this is the @TaskAction annotated method of the task
//            }
//        }
//)