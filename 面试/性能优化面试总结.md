1. 开始阶段：进行培训

   1. 布局优化：
      1. include，merge，viewstub
      2. 绘制优化：ondraw中少创建对象
   2. 内存泄漏优化
      1. 静态变量导致的内存泄漏
      2. 单例模式导致的内存泄漏
      3. 属性动画导致的内存泄漏
      4. Handler导致的内存泄漏
   3. 不做耗时任务
   4. ListView和Bitmap优化
      1. 复用
      2. Bitmap复用
   5. 多使用SparseArray这样优化的集合
   6. 设计模式的培训

2. 项目成熟后：

   =======》线下优化》=========

   1. 启动时间

      ====线下====

      1. 更换启动的主题，增加响应的时间
      2. Application中最早都在单线程中初始化，后来引入了Dispatcher分发器，创建一个无环图进行多线程的执行。
      3. 刚开始手动打点，查看启动的时间，后来引入的AOP方式，进行启动时间的测量。
         1. Whale和Epic， 可以记录两个方法启动时间
            1. Application#attachBaseContext -> MainActivity#onWindowFoucused
         2. AspectJ AOP，开发透明，打印需要的方法
      4. 也是用过TraceView和Systrace来查看方法启动时间，cpu占用时间，找出耗时的方法
         1. Debug.startTraceMethod / Debug.endTraceMethod
         2. TraceCompat.start / TraceCompat.end
         3. traceview，信息全面，包含所有线程；图形展示
         4. systrace，轻量级，开销小；直接反应cpu利用率
      5. 提前加载某些重要的类，可以缩短new创建的时间
      6. 有一个IdleHandler进行一些不是创建时必须的任务，提高启动时间

   2. 内存优化

      1. 加入了LeakCanary第三方库，用观察列表的方式，查看是否有内存泄漏的地方

      2. 使用一个Hook库

         1. Hook主ImageView的setImageBitmap是否符合大小，避免浪费
            1. 重新计算bitmap大小
            2. 复用bitmap
         2. 有怀疑的地方，我们用AS自己的Profile，截取出来一段内存dump文件hprof
            1. 首先直接在AS中查看
            2. 有时我们也会通过MAT来进行分析内存泄漏的地方
         3. 由于显示的数据大，我们添加了largeHeap属性

      3. 现在操作的时候，在onLowMemeory的时候，我们会Debug.dumpHprofData("")分析内存情况

         =====线下=====

      1. 上传文件，有删减

   3. 布局优化

      1. systrace可以显示出Frame耗时时间，及调用方法。用这个作为优化的依据
      2. Choreographer.getInstance().postFrameCallback监测每一帧的耗时，如果大于16ms我们就报警。我们一般用到线下，线上也可以使用
      3. 我们也尝试过用LayoutInflaterCompat.setFactory2来使用自己创建的TextView等一些控件（XML需要反射创建）
      4. 也尝试过用X2C框架提前生成Java代码，但是由于版本升级，应用范围比较小
      5. setContentView是设置布局的方法，我们通过AOP方法，监听每一个setContentView使用的时间。
      6. 曾经写过一个多个头像叠加控件，直接用Canas.clipRect进行裁剪

   4. 卡顿优化

      1. 使用StrictMode，打印虚拟机和线程使用信息。这个只是作为一个参考
      2. TraceView和Systrace都可以看出CPU使用的一些信息
      3. AS自带profier 也可以查看cpu使用情况
      4. Looper.getMainLooper().setMessageLogging()可以查看处理每个Message的具体情况
      5. BlockCanary可以向LeakCanary一样耗时时间
      6. 使用ANR-WatchDog统计线上的耗时信息（发送一个Handler消息，sleep一段时间，判断数字是否修改）
      7. 读取/data/anr/traces.txt有详细的ANR信息
      8. IPC耗时监测， Hook android.os.BinderProxy的transact方法, 打印线程堆栈信息
      9. 对于View是否是空白进行监测 textView.postDelayed(new Runnable() {isBlank()}
      10. Hook Runnable的run方法，调用时间是否卡顿

   5. 线程优化

      1. 使用多线程，自己设置线程创建工厂，写上名称便于查找；HookThread的创建方法，打印堆栈信息
      2. 使用Rxjava线程调度
      3. 设置Thread的优先级
      4. HookThread的创建方法，打印堆栈信息
      5. 创建初始化数据的时候（筛选）

   6. 网络优化

      1. DNS加快访问速度
      2. 使用facebook的stetho，设置在Okhttp，可以通过网页访问
      3. charles断点功能，模拟弱网环境查看问题。及一些访问的参数是否正确
      4. LoggerIngercepter打印信息是必要的排除问题的手段
      5. TrafficsStats.getMobileRxBytes()获取流量的访问信息
      6. API23之后，可以通过NetworkManager获取某一时段的流量信息
      7. 设置缓存
      8. 访问网络的时候使用gzip压缩
      9. 给OkHttp设置EventListener，监听访问成功率的一些信息

   7. 电量优化

      1. WaitLock使用情况，超时取消
      2. JobScheduler设置在某一特定情况下执行操作

   8. 瘦身优化

      1. 都在主Dex中
      2. 混淆代码
      3. 混淆资源
      4. 移除无用代码，和资源
      5. 对于一些自定义库我们需要知道占用大小，必要的情况下我们自己修改代码
      6. 资源在线化
      7. 移除不必要的so文件
      8. so也可以动态加载

   9. 稳定性优化

      1. 添加CrashHandler，我们用的bugly，对于native崩溃也有统计
      2. 在一下必要的try-catch的信息，我们有选择性的上报
      3. 后台建立的一个开关，对于一个新的表格系统，后台决定是否使用（兜底策略）
      4. 加入一些热修复功能，我也有一些研究
      5. 









> ARTHook 可以Hook系统方法
>
> AspectJ：非系统方法