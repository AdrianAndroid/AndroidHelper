

# 1. 插件化

## 1. 1 加载插件apk

## 1.2 DexEelments合并

```
// 获取pathList字段(DexPathList类)
Class<?> clazz = Class.forName("dalvik.system.BaseDexClassLoader");
Field pathListField = clazz.getDeclaredField("pathList");
pathListField.setAccessible(true);
// 获取dexElement字段
Class<?> dexPathListClass = Class.forName("dalvik.system.DexPathList");
Field dexElementsField = dexPathListClass.getDeclaredField("dexElements");
dexElementsField.setAccessible(true);

/////////////////////
// 宿主的 类加载器
/////////////////////
ClassLoader pathClassLoader = context.getClassLoader();
// DexPathList类的对象
Object hostPathList = pathListField.get(pathClassLoader);
// 宿主的 dexElements
Object[] hostDexElements = (Object[]) dexElementsField.get(hostPathList);

/////////////////////
// 插件的 类加载器
/////////////////////
// apkPath = "/sdcard/plugin-debug.apk";
// 获取DexClassLoader类中的属性pathList值
ClassLoader dexClassLoader = new DexClassLoader(
        apkPath, 
        context.getCacheDir().getAbsolutePath(),
        null, 
        pathClassLoader);
// DexPathList类的对象
Object pluginPathList = pathListField.get(dexClassLoader);
// 插件的 dexElements
// 获取pathList中的属性dexElements[]的值--插件的dexElements[]
Object[] pluginDexElements = (Object[]) dexElementsField.get(pluginPathList);



 // 创建一个新数组
Object[] newDexElements = 		
		(Object[])Array.newInstance(hostDexElements.getClass().getComponentType(),
    									hostDexElements.length + pluginDexElements.length);

//将插件+宿主的dexElements[]值放入新的数组中
System.arraycopy(hostDexElements, 0, newDexElements, 0, hostDexElements.length);
System.arraycopy(pluginDexElements, 0, newDexElements, hostDexElements.length, 
										pluginDexElements.length);

// 赋值 
// hostDexElements = newDexElements
dexElementsField.set(hostPathList, newDexElements);
```

## 3.3 资源修复

```
//创建一个新的资源
public static Resources loadResources(Context context) {
	try{
		AssetManager assetManager = AssetManager.class.newInstance();
		// 让这个AssetManager对象加载的资源为插件的
		Method addAssetPathMethod = AssetManager.class.getMethod("addAssetPath", String.class);
		addAssetPathMethod.invoke(assetManager, apkPath);
		Resources resources = context.getResources();
		//加载插件的资源resources
		return new Resources(assetManager, resources.getDisplayMetrics(), 
						resources.getConfiguration());
	} catch(Exception e){
	
	}
	return null;
}

// 如果不为空，就替换Resources
// 防止崩溃的话，直接使用LayoutInfalter.from().inflate();
```

## 3.4 启动插件Activity

![](/Users/flannery/Desktop/AndroidHelper/面试/热修复总结.assets/image-20210512235139291.png)

* 调用AMSHook住

* 回来通过Handler恢复到插件Activity(LAUNCH_ACTIVITY)

### 3.4.1 hookAMS(动态代理)

```java
//////////////////////////
// hookAMS
//////////////////////////
//public static void hookAMS() {
//    try {
// 获取 singleton 对象
Field singletonField = null;
if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) { // 小于8.0
    Class<?> clazz = Class.forName("android.app.ActivityManagerNative");
    singletonField = clazz.getDeclaredField("gDefault");
} else {
    Class<?> clazz = Class.forName("android.app.ActivityManager");
    singletonField = clazz.getDeclaredField("IActivityManagerSingleton");
}

singletonField.setAccessible(true);
Object singleton = singletonField.get(null);

// 获取 系统的 IActivityManager 对象
Class<?> singletonClass = Class.forName("android.util.Singleton");
Field mInstanceField = singletonClass.getDeclaredField("mInstance");
mInstanceField.setAccessible(true);
final Object mInstance = mInstanceField.get(singleton);

Class<?> iActivityManagerClass = Class.forName("android.app.IActivityManager");

// 创建动态代理对象
Object proxyInstance = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),
        new Class[]{iActivityManagerClass}, new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                // do something
                // Intent的修改 -- 过滤
                /**
                 * IActivityManager类的方法
                 * startActivity(whoThread, who.getBasePackageName(), intent,
                 *                         intent.resolveTypeIfNeeded(who.getContentResolver()),
                 *                         token, target != null ? target.mEmbeddedID : null,
                 *                         requestCode, 0, null, options)
                 */
                // 过滤
                if ("startActivity".equals(method.getName())) {
                    int index = -1;

                    for (int i = 0; i < args.length; i++) {
                        if (args[i] instanceof Intent) {
                            index = i;
                            break;
                        }
                    }
                    // 启动插件的
                    Intent intent = (Intent) args[index];

                    Intent proxyIntent = new Intent();
                    proxyIntent.setClassName("com.enjoy.leo_plugin",
                            "com.enjoy.leo_plugin.ProxyActivity");

                    proxyIntent.putExtra(TARGET_INTENT, intent);

                    args[index] = proxyIntent;
                }

                // args  method需要的参数  --- 不改变原有的执行流程
                // mInstance 系统的 IActivityManager 对象
                return method.invoke(mInstance, args);
            }
        });

// ActivityManager.getService() 替换成 proxyInstance
mInstanceField.set(singleton, proxyInstance);
//    } catch (Exception e) {
//        e.printStackTrace();
//    }
//}


```

### 3.4.2 HookHandler

```
//////////////////////////
// hookHandler
//////////////////////////
//public static void hookHandler() {
//    try {
// 获取 ActivityThread 类的 Class 对象
Class<?> clazz = Class.forName("android.app.ActivityThread");

// 获取 ActivityThread 对象
Field activityThreadField = clazz.getDeclaredField("sCurrentActivityThread");
activityThreadField.setAccessible(true);
Object activityThread = activityThreadField.get(null);

// 获取 mH 对象
Field mHField = clazz.getDeclaredField("mH");
mHField.setAccessible(true);
final Handler mH = (Handler) mHField.get(activityThread);

Field mCallbackField = Handler.class.getDeclaredField("mCallback");
mCallbackField.setAccessible(true);

// 创建的 callback
Handler.Callback callback = new Handler.Callback() {

    @Override
    public boolean handleMessage(@NonNull Message msg) {
        // 通过msg  可以拿到 Intent，可以换回执行插件的Intent

        // 找到 Intent的方便替换的地方  --- 在这个类里面 ActivityClientRecord --- Intent intent 非静态
        // msg.obj == ActivityClientRecord
        switch (msg.what) {
            case 100: //LAUNCH_ACTIVITY
                try {
                    Field intentField = msg.obj.getClass().getDeclaredField("intent");
                    intentField.setAccessible(true);
                    // 启动代理Intent
                    Intent proxyIntent = (Intent) intentField.get(msg.obj);
                    // 启动插件的 Intent
                    Intent intent = proxyIntent.getParcelableExtra(TARGET_INTENT);
                    if (intent != null) {
                        intentField.set(msg.obj, intent);
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
                break;
            case 159:
                try {
                    // 获取 mActivityCallbacks 对象
                    Field mActivityCallbacksField = msg.obj.getClass()
                            .getDeclaredField("mActivityCallbacks");

                    mActivityCallbacksField.setAccessible(true);
                    List mActivityCallbacks = (List) mActivityCallbacksField.get(msg.obj);

                    for (int i = 0; i < mActivityCallbacks.size(); i++) {
                        if (mActivityCallbacks.get(i).getClass().getName()
                                .equals("android.app.servertransaction.LaunchActivityItem")) {
                            Object launchActivityItem = mActivityCallbacks.get(i);

                            // 获取启动代理的 Intent
                            Field mIntentField = launchActivityItem.getClass()
                                    .getDeclaredField("mIntent");
                            mIntentField.setAccessible(true);
                            Intent proxyIntent = (Intent) mIntentField.get(launchActivityItem);

                            // 目标 intent 替换 proxyIntent
                            Intent intent = proxyIntent.getParcelableExtra(TARGET_INTENT);
                            if (intent != null) {
                                mIntentField.set(launchActivityItem, intent);
                            }
                        }
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
                break;
        }
        // 必须 return false
        return false;
    }
};

// 替换系统的 callBack
mCallbackField.set(mH, callback);
//    } catch (Exception e) {
//        e.printStackTrace();
//    }
//}
```



# 2. 热修复

## 2.1 AndFix (apk差分包)

## 2.2 Robust(字节码插桩)

## 2.3 Thinker (dexelements合并)

## 2.4 Qzone（dex差分包）

## 2.5 Android N混合编译

​	自己创建一个PathClassLoader， 不用系统的

​	Thread.currentThread().setContextClassLoader(classLoader);

## 2.6 CLASS_PISPRIVATEFIED

​	字节码插桩一个类

​	AntilazyLoad类被打包成一个单独的hack.dex

## 2.7 ASM字节码插桩

## 2.8 gradle插件开发

​	buildSrc目录，自动创建工程









# 3. 换肤

## 3.1 加载apk资源

```
    public void loadSkin(String skinPath) {
        if (TextUtils.isEmpty(skinPath)) {
            //还原默认皮肤
            SkinPreference.getInstance().reset();
            SkinResources.getInstance().reset();
        } else {
            try {
                //宿主app的 resources;
                Resources appResource = mContext.getResources();
//
                //反射创建AssetManager 与 Resource
                AssetManager assetManager = AssetManager.class.newInstance();
                //资源路径设置 目录或压缩包
                Method addAssetPath = assetManager.getClass().getMethod("addAssetPath",
                        String.class);
                addAssetPath.invoke(assetManager, skinPath);

                //根据当前的设备显示器信息 与 配置(横竖屏、语言等) 创建Resources
                Resources skinResource = new Resources(assetManager, appResource.getDisplayMetrics
                        (), appResource.getConfiguration());

                //获取外部Apk(皮肤包) 包名
                PackageManager mPm = mContext.getPackageManager();
                PackageInfo info = mPm.getPackageArchiveInfo(skinPath, PackageManager
                        .GET_ACTIVITIES);
                String packageName = info.packageName;
                SkinResources.getInstance().applySkin(skinResource, packageName);

                //记录
                SkinPreference.getInstance().setSkin(skinPath);


            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        //通知采集的View 更新皮肤
        //被观察者改变 通知所有观察者
        setChanged();
        notifyObservers(null);
    }

}
```

## 3.2 保存所有属性

```
 //记录下一个VIEW身上哪几个属性需要换肤textColor/src
    public void look(View view, AttributeSet attrs) {
        List<SkinPair> mSkinPars = new ArrayList<>();

        for (int i = 0; i < attrs.getAttributeCount(); i++) {
            //获得属性名  textColor/background
            String attributeName = attrs.getAttributeName(i);
            if (mAttributes.contains(attributeName)) {
                // #
                // ?722727272
                // @722727272
                String attributeValue = attrs.getAttributeValue(i);
                // 比如color 以#开头表示写死的颜色 不可用于换肤
                if (attributeValue.startsWith("#")) {
                    continue;
                }
                int resId;
                // 以 ？开头的表示使用 属性
                if (attributeValue.startsWith("?")) {
                    int attrId = Integer.parseInt(attributeValue.substring(1));
                    resId = SkinThemeUtils.getResId(view.getContext(), new int[]{attrId})[0];
                } else {
                    // 正常以 @ 开头
                    resId = Integer.parseInt(attributeValue.substring(1));
                }

                SkinPair skinPair = new SkinPair(attributeName, resId);
                mSkinPars.add(skinPair);
            }
        }

        if (!mSkinPars.isEmpty() || view instanceof SkinViewSupport) {
            SkinView skinView = new SkinView(view, mSkinPars);
            // 如果选择过皮肤 ，调用 一次 applySkin 加载皮肤的资源
            skinView.applySkin();
            mSkinViews.add(skinView);
        }
    }
```

## 3.3 获取资源

```
   /**
     * 1.通过原始app中的resId(R.color.XX)获取到自己的 名字
     * 2.根据名字和类型获取皮肤包中的ID
     */
    public int getIdentifier(int resId){
        if(isDefaultSkin){
            return resId;
        }
        String resName=mAppResources.getResourceEntryName(resId); // 获取原来的name
        String resType=mAppResources.getResourceTypeName(resId); // 获取原来的type
        int skinId=mSkinResources.getIdentifier(resName,resType,mSkinPkgName); // 获取apk的资源id
        return skinId;
    }
```

