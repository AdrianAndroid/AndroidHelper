
2. 排序算法


目录：
周三：
性能优化

周四：
Android面试题
3. OKHTTP等快速浏览

周五：
10：30面试
理发，打印简历，取快递

周五：4。23  美团
周六：4.24   快看漫画
周日：       好未来
周一：       百度
周二：       拉钩
周三：       滴滴


✅ 1. Handler
✅ 3. 性能优化 崩溃（java崩溃原理，native崩溃）
✅    内存泄漏
✅        1 静态变量导致的内存泄漏
✅        2 单例模式导致的内存泄漏
✅        3 属性动画导致的内存泄漏
✅ 4. SparseArray， ArrayMap，HashMap
✅ 6. LiveData 源码解析， jetpack关键的一些东西
✅     https://blog.csdn.net/c10WTiybQ1Ye3/article/details/107852553  LifeCycle
✅         是ReportFragment，一个没有UI的Fragment
✅     https://www.jianshu.com/p/ec15396192c6   LiveData
✅         活跃状态（STARTED/RESUMED）
✅
✅     https://www.jianshu.com/p/4e9a1ab05bb5   DataBinding
✅ databinding源码
✅ 7. 热修复（dex， classloader，资源替换） 细节很重要！！！
✅     https://github.com/DroidPluginTeam/DroidPlugin 360
✅     Android  C++替换method
✅     Robust
✅     tinker
✅ 8. 启动模式（四种）：写个例子了解一下，别在这里卡壳了。
✅ 	1，standard
✅ 	2，singleTop  在栈顶就复用，不在就创建新的
✅ 	3，singleTask 有Activity，就复用，并清空上面的
✅ 	4，singleInstance 全局就有一个
✅ 	https://www.cnblogs.com/claireyuancy/p/7387696.html
✅ 14. OKHttp中的Dispatcher    https://blog.csdn.net/lxk_1993/article/details/101449342
✅ 19. mmap原理 void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset)
✅ 22. 锁机制(图灵教育)
✅       基于线程的LockSupport.park()/unpark()
✅       基于monitor机制的wait()/notify
✅       线程的中断机制
✅          public static boolean interrupted() {
✅                return currentThread().isInterrupted(true); //会停止
✅            }
✅    public boolean isInterrupted() {
✅        return isInterrupted(false); //不会停止
✅    }
✅ 23. ARG_8888 格式
✅     ARGB_8888：ARGB 四个通道的值都是 8 位，加起来 32 位，也就是 4 个字节。每个像素点占用 4 个字节的大小。
✅     ARGB_4444：ARGB 四个通道的值都是 4 位，加起来 16 位，也就是 2 个字节。每个像素点占用 2 个字节的大小。
✅     RGB_565：RGB 三个通道分别是 5 位、6 位、5 位，没有 A 通道，加起来 16 位，也就是 2 个字节。每个像素点占用 2 个字节的大小。
✅     ALPHA_8：只有 A 通道，占 8 位，1 个字节。每个像素点占用 1 个字节的大小。
✅
✅     ARGB_4444 图片的失真是比较严重的。
✅     RGB_565 图片的失真虽然很小，但是没有透明度。
✅     ALPHA_8 只有透明度，没有颜色值。对于在图片上设置遮盖的效果的是有很有用。
✅
✅     https://blog.csdn.net/qq_31939617/article/details/88599387
✅ 24. ThreadLocal
✅     set --> 获取ThreadLocapMap
✅     https://juejin.cn/post/6958991265933295624?utm_source=gold_browser_extension
✅///////百度搜索////////
✅26。 AsyncTask源码解析
✅    使用线程池复用
✅    有一个阻塞队列
✅    通过handler
✅    使用FutureTask做异步执行
✅20. LeakCanary源码解析
✅    https://blog.csdn.net/qq_31339141/article/details/104495508  1.6.3 / 2.2
✅    https://blog.csdn.net/ethanco/article/details/107926668  1.6.3
✅    https://bboylin.github.io/2019/07/14/leakcanary2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/
✅    观察列表 WeakReference weak = new WeakReference(object, new Reference()); ->HashMap<String, KeyWeakReference>
✅    怀疑列表 HashMap<String, KeyWeakReference>
✅25. Rxjava快速浏览
✅    map 进行了封装ObservableMap
✅    subscribeActual 开始回调，先调用subscribe
✅    每一次调用都是一次封装，直到subscribeActual
✅    .subscribeOn(...) 上面的操作切换
✅    .observeOn(...)  下面的操作切换
✅15. SharedPreference源码解析
✅    https://blog.csdn.net/tangedegushi/article/details/82383509
✅    1. 全部读取出来放到缓存中
✅    loadFromDisk   通过子线程读取
✅    2. 首次加载是线程阻塞的
✅    3. apply() 先保存到内存中，然后子线程保存到磁盘
✅       commit()  先保存到内存，然后理解同步到磁盘
✅12. EventBus源码
✅    https://blog.csdn.net/submit66/article/details/90268462
✅    https://www.jianshu.com/p/83e44261e095  源码分析
✅    https://juejin.cn/post/5b66df92e51d45348813ae3f  使用
✅    1.将观察者和订阅方法封装成一个Subscription对象
✅    2.用到CopyOnWriteArraylist（适合多读少写）存储所对应的Subscription对象
✅    3.通过Map<Class<?>,CopyOnWriteArrayList<Subscription>>类型的哈希表来维护这个映射关系
✅    4.对Subscription对象的列表进行遍历，并根据订阅方法的优先级，为当前的Subscription对象找一个合适的位置，放入队列中
✅    5.获取指定的观察者对应的观察事件类型
✅    6.如果是粘性的，根据是否将当前缓存的信息发送到新订阅的的方法
✅    post
✅    1 根据ThreadLocal获取单独的队列
✅    2 遍历队列中所有的消息发送
✅    总结：
✅    1 在EventBus中，使用@Subscribe注解指定的ThreadMode
✅        主线程使用Handler
✅        子线程用线程池发送
✅    2 内部使用了缓存
✅    3 粘性事件单独一个哈希表存储
✅21. ANR原理解析(视频)
✅    https://blog.csdn.net/u012439416/article/details/78407242
✅    https://blog.csdn.net/tangxueqin/article/details/79220030
✅    https://blog.csdn.net/jasonwang18/article/details/60326807
✅    jianshu.com/p/914df9091a80
✅    WatchDog
✅    FileProvider
✅    https://zhuanlan.zhihu.com/p/141203533
✅      (android 4.0)ActivityManagerService # Handler # handleMessage # case SHOW_NOT_RESPONDING_MSG
✅      new AppNotRespondingDialog
✅    https://www.cnblogs.com/tiantianbyconan/p/5017056.html
✅2.Binder（怎么叙述）-原理要搞明白
✅    https://blog.csdn.net/augfun/article/details/82343249
✅    DESCRIPTOR  唯一标识
✅    asBinder    返回当前的Binder对象
✅    onTransact
✅崩溃日志
✅    https://blog.csdn.net/leeo1010/article/details/50522892
✅    https://blog.csdn.net/qq_36523667/article/details/80314856
✅    先保存原先的 mDefaultCrashHandler = Thread.getDefaultUncaughtExceptionHandler();
✅    在设置最新的 Thread.setDefaultUncaughtExceptionHandler(this);
✅    native 信号捕获机制
✅WMS
✅    如何添加Window addView  WindowManagerService进行管理
✅ //AMS
✅  //PKMS
✅ 5. Activity启动流程
✅     https://blog.csdn.net/u012267215/article/details/91406211
✅     流程
✅         startActivityForResult
✅         execStartActivity
✅         ActivityManagerNative.getDefault().startActivity()
✅         ActivityStack#resumeTopActivityLocked
✅         ActivityStackSupervisor#startSpecificActivityLocked
✅         IAcpplicaitonThread#schedulePauseActivity
✅         ApplicaitonThread#scheduleLaunchActivity
✅             new ActivityClientRecord
✅         ActivityThread#performLauchActivity
✅             1 从ActivityClientRecord中获取启动的Activity的组件信息
✅             2 通过Instrumentation的newActivity方法使用类加载器创建Activity对象
✅             3 通过LoadedApk的makeApplicaiton方法来尝试创建Application对象
✅             4 创建ContextImpl对象并通过Activity的attach方法来完成一些重要数据的初始化（attach）
✅             5 调用Activity的onCreate方法
✅         通过Instrumentation调用到AMS，并通过反射创建一个Activity，然后调用生命周期
✅         ？？怎么实现的
✅         不错的启动流程追踪：https://www.cnblogs.com/tiantianbyconan/p/5017056.html
✅
✅
✅11. 自定义分发事件（如何复述）/ 事件分发（两个button怎么办）
✅    https://www.jianshu.com/p/7d50a6b0b6af
✅    setOnClickListener
✅        onTouchEvent->performClick
✅    setOnLongClickListener
✅        onTouchEvent->checkForLongClick
✅    setOnTouchListener
✅        View->dispatchTouchEvent->li.mOnTouchListener.onTouch()
✅    内部拦截法：子View处理冲突(requestDisallowInerceptTouchEvent)
✅    外部拦截法：父容器处理冲突（onInterceptTouchEvent）
✅    MOVE拦截时间，不拦截呢？
✅        1。 mFirstTouch=null
✅        2。 恢复？onInterceptTouchEvent==false，不再拦截，重新获取到这个View
✅9. 手写ViewPager
✅    View的事件体系
✅    Scroller 丝滑滚动
✅    translationx 移动
✅    GestureDector 点击事件等
✅10. 手写PhotoView
✅    OverScroller https://blog.csdn.net/chaoyangsun/article/details/94398225
✅18. Bitmap实现（LEO老师）
✅    LruCache中回收的放入复用池中
✅    inBitmap复用
✅//////看视频////////
5. Fragment（看视频）和Activity
✅ 27。 Multidex分包：将指定的类打包到主dex中
✅     https://blog.csdn.net/qq_36282231/ar ticle/details/81026296
✅28。ABTest
✅    https://www.jianshu.com/p/4e7a271cd54a
✅ 29。混淆
✅30。 Android开发艺术探索第3章 View的事件体系


美团面试：
5.19  下午三点茄子zoom                  晚上7点 小米
5.20  搜狗输入法 上午11点  下午2点 字节   高途 8点

5.21  搜狗二面11点        京东 下午2点   百度贴吧 4点之后   小米二面 5点之后
周六
周日   搜狗三面 下午4点半
5.24一  快手 11点          新浪 2点      keep  晚上6点  字节二面 8点
5.25二  夜神 十点          下午3点 高途二面      百度贴吧 5点（面了2次）
5.26三  快手 11点          小米3面（3+2）2：00
5.27四  快手二面 11点       陌陌科技 3点        新浪二面5点

//--->callback()
1。 设计模式
2。六大设计模式
3。 内存优化
4。HashMap put 什么时候扩容 添加之后resize
6. hashmap (h = key.hashCode()) ^ (h >>> 16)  i = (n - 1) & hash] (高低位混合&长度)==索引
5. >> 左移动 >>> 无符号右移
6. https://blog.csdn.net/qingdujun/article/details/82343756 海量数据
mvvm

1. EventBus 粘性时间
2。 Handler postInvalidate
3。 ARouter
4。Toast
5. startActivityForResult
6。 MVVM
7. ViewModel